rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function signedIn() { return request.auth != null; }

    // ===== Helpers =====

    function getProject(projectId) {
      return get(/databases/$(database)/documents/projects/$(projectId));
    }

    function isProjectMember(projectId) {
      let project = getProject(projectId);
      return project != null && (
        // owner is member
        project.data.ownerId == request.auth.uid ||

        // memberIds contains uid (guard key exists)
        (project.data.keys().hasAny(['memberIds']) &&
         project.data.memberIds.hasAny([request.auth.uid])) ||

        // roles map contains uid (guard key exists)
        (project.data.keys().hasAny(['roles']) &&
         project.data.roles.keys().hasAny([request.auth.uid]))
      );
    }

    function isProjectAdmin(projectId) {
      let project = getProject(projectId);
      return project != null && (
        // owner is admin
        project.data.ownerId == request.auth.uid ||
        (
          project.data.keys().hasAny(['roles']) &&
          project.data.roles.keys().hasAny([request.auth.uid]) &&
          project.data.roles[request.auth.uid] == 'admin'
        )
      );
    }

    function isProjectViewer(projectId) {
      let project = getProject(projectId);
      return project != null &&
        // owner never viewer
        project.data.ownerId != request.auth.uid &&
        project.data.keys().hasAny(['roles']) &&
        project.data.roles.keys().hasAny([request.auth.uid]) &&
        project.data.roles[request.auth.uid] == 'viewer';
    }

    function isInvited(project) {
      return project.data.keys().hasAny(['invitedMemberIds']) &&
             project.data.invitedMemberIds != null &&
             project.data.invitedMemberIds.hasAny([request.auth.uid]);
    }

    function isValidNewProject() {
      let data = request.resource.data;
      return data.keys().hasAll(['name', 'key', 'ownerId', 'memberIds'])
        && data.name is string && data.name.size() > 0
        && data.key is string && data.key.size() > 0
        && data.ownerId == request.auth.uid
        && data.memberIds is list
        && data.memberIds.hasAll([request.auth.uid]);
    }

    function isValidIssue() {
      let data = request.resource.data;
      return data.title is string && data.title.size() > 0
        && (!data.keys().hasAny(['type']) || data.type in ['story', 'bug', 'task']);
    }

    function notChangingProjectId() {
      return request.resource.data.projectId == resource.data.projectId;
    }

    // ===== Rules =====

    match /projects/{projectId} {

      // Read: member OR invited OR has role in roles map
      allow read: if signedIn() && (
        resource.data.ownerId == request.auth.uid ||
        (resource.data.keys().hasAny(['memberIds']) &&
         resource.data.memberIds.hasAny([request.auth.uid])) ||
        (resource.data.keys().hasAny(['roles']) &&
         resource.data.roles.keys().hasAny([request.auth.uid])) ||
        (resource.data.keys().hasAny(['invitedMemberIds']) &&
         resource.data.invitedMemberIds != null &&
         resource.data.invitedMemberIds.hasAny([request.auth.uid]))
      );

      // Create: strict schema
      allow create: if signedIn() && isValidNewProject();

      // Update:
      // - Owner: full update BUT cannot change ownerId (and optionally name/key if you want)
      // - Member/Invited: cannot change name/key/ownerId
      allow update: if signedIn() && (
        (
          resource.data.ownerId == request.auth.uid &&
          !request.resource.data.diff(resource.data).affectedKeys().hasAny(['ownerId'])
        ) ||
        (
          (
            (resource.data.keys().hasAny(['memberIds']) &&
             resource.data.memberIds.hasAny([request.auth.uid])) ||
            (
              resource.data.keys().hasAny(['invitedMemberIds']) &&
              resource.data.invitedMemberIds != null &&
              resource.data.invitedMemberIds.hasAny([request.auth.uid])
            )
          ) &&
          !request.resource.data.diff(resource.data).affectedKeys().hasAny(['name', 'key', 'ownerId'])
        )
      );

      // Delete: only owner
      allow delete: if signedIn() && resource.data.ownerId == request.auth.uid;
    }

    match /issues/{issueId} {

      allow read: if signedIn() && (
        resource.data.assigneeId == request.auth.uid ||
        isProjectMember(resource.data.projectId)
      );

      allow create: if signedIn()
        && isProjectMember(request.resource.data.projectId)
        && !isProjectViewer(request.resource.data.projectId)
        && isValidIssue();

      // Update:
      // - Base: must be member, not viewer, not changing projectId
      // - Assignee/Reporter/Admin: can update anything (except projectId already blocked)
      // - Member thường: ONLY allowed to change status & order
      allow update: if signedIn()
        && isProjectMember(resource.data.projectId)
        && !isProjectViewer(resource.data.projectId)
        && notChangingProjectId()
        && (
          (
            resource.data.assigneeId == request.auth.uid ||
            resource.data.reporterId == request.auth.uid ||
            isProjectAdmin(resource.data.projectId)
          ) ||
          (
            // Strict: only status & order
            request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'order'])
          )
        );

      allow delete: if signedIn() && (
        resource.data.reporterId == request.auth.uid ||
        isProjectAdmin(resource.data.projectId)
      );
    }

    match /sprints/{sprintId} {

      allow read: if signedIn() && isProjectMember(resource.data.projectId);

      // Strict: only admin can create/delete
      allow create: if signedIn()
        && isProjectAdmin(request.resource.data.projectId)
        && !isProjectViewer(request.resource.data.projectId);

      // Update:
      // - Admin: can update anything
      // - Member: only allowed to change status (Start/Complete)
      allow update: if signedIn()
        && isProjectMember(resource.data.projectId)
        && !isProjectViewer(resource.data.projectId)
        && (
          isProjectAdmin(resource.data.projectId) ||
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status'])
        );

      allow delete: if signedIn() && isProjectAdmin(resource.data.projectId);
    }

    match /users/{uid} {
      allow read: if signedIn();
      allow write: if signedIn() && request.auth.uid == uid;
    }
  }
}
